from __future__ import annotations

from collections import deque
from collections.abc import Collection
from pathlib import Path
from dataclasses import dataclass, field
from concurrent.futures import as_completed, ThreadPoolExecutor
from typing import (
    Callable,
    Deque,
    Dict,
    List,
    Literal,
    Optional,
    Set,
    TypeAlias,
    Union
)

import libcst as cst

PythonSource: TypeAlias = Union[str, Path]
GenModels: TypeAlias = Literal[
    'dataclass', 'pydantic', 'attrs', 'django-orm'
]

_MAX_RETRIES = 3

def _is_dataclass_model(node: cst.ClassDef) -> bool:
    """
    Private function to determine if a `libcst.ClassDef` object is
    dataclass.
    """
    return (
        isinstance(decorator.decorator, cst.Name)
        and decorator.decorator.value == "dataclass"
        for decorator in node.decorators
    )


def _is_pydantic_model(node: cst.ClassDef) -> bool:
    """
    Private function to determine if a `libcst.ClassDef` object is a
    pydantic BaseModel.
    """
    return any(
        isinstance(base_class.value, cst.Name) and
        base_class.value.value == 'BaseModel'
        for base_class in node.bases
    )


def _root_finder(defs: Set[str], refs: Set[str]) -> Optional[List[str]]:
    """
    Private method to identify and return the classes that are not
    referenced by others.
    """
    root_classes = [
        class_name for class_name in defs if class_name not in refs
    ]
    return None if not root_classes else root_classes


def _find_all_classes_in_subscript(subscript: cst.Subscript) -> Set[str]:
    """
    A private function that returns a set of class names found
    within a `libcst.Subscript` object. Traverses recursively through
    the entire object to find all references to classes.
    """
    classes_found: Set[str] = set()

    def traversal(slice_index: cst.Index) -> None:
        slice_index_value = slice_index.value

        # If the value of the index is a cst.Subscript, then
        # iteration through each value needs to occur and
        # recursion continues
        if isinstance(slice_index_value, cst.Subscript):
            for sub_element in slice_index_value.slice:
                traversal(sub_element.slice)

        # If the value is a cst.Attribute, then extract the
        # value of the top-level portion of the attribute
        elif isinstance(slice_index_value, cst.Attribute):
            classes_found.add(slice_index_value.attr.value)

        # Simply extract the value if object is a cst.Name
        elif isinstance(slice_index_value, cst.Name):
            classes_found.add(slice_index_value.value)

        # If there is a reference to a class as a string, due
        # to TYPE_CHECKING, then strip the value of extra
        # quotations and add to set of classes encountered
        elif isinstance(slice_index_value, cst.SimpleString):
            classes_found.add(slice_index_value.value.strip('"'))

    for sub_element in subscript.slice:
        traversal(sub_element.slice)

    return classes_found


class XSDataRootFinderError(Exception):
    """"""
    def __init__(self, message: str, source: PythonSource) -> None:
        self.message = message
        self.source = source

    def __str__(self) -> str:
        return repr(self)
    
    def __repr__(self) -> str:
        return self.message


@dataclass
class _XSDataCollectedClasses:
    refs: Set[str] = field(default_factory=set)
    defs: Set[str] = field(default_factory=set)
    
    def consoildate_classes(self, visitor: _XSDataRootFinderVisitor) -> None:
        """
        Merge referenced and defined classes from a visitor into the current
        instance.
        """
        self.refs.update(visitor.ref_classes)
        self.defs.update(visitor.defined_classes)

    def root_finder(self) -> Optional[List[str]]:
        """Identify and return the classes that are not referenced by others."""
        return _root_finder(defs=self.defs, refs=self.refs)
    

@dataclass(frozen=True)
class MultiprocessingSettings:
    enabled: bool = False
    max_workers: Optional[int] = None
    timeout: Optional[int] = None


class _XSDataRootFinderVisitor(cst.CSTVisitor):
    def __init__(self, gen_model: GenModels) -> None:
        self.gen_model = gen_model
        self.class_trace: Deque[cst.ClassDef] = deque([])
        self.ref_classes: Set[str] = set()
        self.defined_classes: Set[str] = set()

    def _is_relevant_model(self) -> bool:
        """
        A private function that determines if a given `libcst.ClassDef`
        object is a class that was generated by `xsdata`.
        """
        MODELS_CHECKS: Dict[GenModels, Callable[[cst.ClassDef]], bool] = {
            'dataclass': _is_dataclass_model,
            'pydantic': _is_pydantic_model,
            'attrs': '',
            'django-orm': ''
        }

        model_func = MODELS_CHECKS.get(self.gen_model)
        class_node = self.class_trace.popleft()
        self.class_trace.appendleft(class_node)
        return model_func(class_node)

    def _attribute_ann_assign(self, node: cst.Attribute) -> None:
        """Handle annotations that are qualified names (e.g., module.Class)."""
        class_name = node.attr.value
        self.ref_classes.add(class_name)

    def _name_ann_assign(self, node: cst.Name) -> None:
        """Handle annotations that are simple names (e.g., int, MyClass)."""
        class_name = node.value
        self.ref_classes.add(class_name)

    def _subscript_ann_assign(self, node: cst.Subscript) -> None:
        """Handle annotations that are subscripted types (e.g., List[int])."""
        classes_found = _find_all_classes_in_subscript(node)
        self.ref_classes.update(classes_found)

    def visit_ClassDef(self, node: cst.ClassDef) -> None:
        """Set the currently visited class definition."""
        if not self.class_trace:
            self.defined_classes.add(node.name.value)
        
        self.class_trace.appendleft(node)
    
    def leave_ClassDef(self, _: cst.ClassDef) -> None:
        """Clear the currently visited class definition."""
        _ = self.class_trace.popleft()

    def visit_AnnAssign(self, node: cst.AnnAssign) -> None:
        """Identify and process annotations within class definitions."""
        if self.class_trace and self._is_relevant_model():
            annotation_node = node.annotation.annotation

            # If the annotation is a cst.Subscript, which is
            # represented like:
            #   - List[int], Dict[str, List[int]], Union[int, str],
            #     Optional[int]
            if isinstance(annotation_node, cst.Subscript):
                self._subscript_ann_assign(annotation_node)

            # If the annotation is a cst.Name which is
            # represented like:
            #   - int, ClassDef, MyClass
            elif isinstance(annotation_node, cst.Name):
                self._name_ann_assign(annotation_node)

            # If the annotation is a cst.Attribute which can
            # be represented like:
            #   - typing.List, libcst.ClassDef, my_module.MyClass
            elif isinstance(annotation_node, cst.Attribute):
                self._attribute_ann_assign(annotation_node)

    def root_finder(self) -> Optional[List[str]]:
        """Identify and return the classes that are not referenced by others."""
        return _root_finder(defs=self.defined_classes, refs=self.ref_classes)


def _python_source_visit(source: PythonSource, gen_model: GenModels) -> _XSDataRootFinderVisitor:
    """Parse a Python source file and extract class definitions and references."""
    with open(source, "r") as gen_py_file:
        source = gen_py_file.read()

    python_module = cst.parse_module(source)
    visitor = _XSDataRootFinderVisitor(gen_model)
    python_module.visit(visitor)
    return visitor


def _visit_and_consolidate(
    source: PythonSource, gen_model: GenModels, consolidated: _XSDataCollectedClasses
) -> None:
    """Wrapper function for processing a single source file in a thread pool."""
    visitor =  _python_source_visit(source, gen_model)
    consolidated.consoildate_classes(visitor)


def root_finder(source: PythonSource, gen_model: GenModels = 'dataclass') -> Optional[List[str]]:
    """Identify and return unreferenced classes from a single Python source file."""
    visitor = _python_source_visit(source, gen_model)
    return visitor.root_finder()


def root_finders(
    sources: Collection[PythonSource],
    gen_model: GenModels = 'dataclass',
    multiprocessing: MultiprocessingSettings = MultiprocessingSettings()
) -> Optional[List[str]]:
    """Identify and return unreferenced classes from multiple Python source files."""
    consolidated_classes = _XSDataCollectedClasses()

    if multiprocessing.enabled:
        with ThreadPoolExecutor(multiprocessing.max_workers) as thread_executor:
            futures = {
                thread_executor.submit(
                    _visit_and_consolidate, source, gen_model, consolidated_classes
                ): source
                for source in sources
            }

            for future in as_completed(futures):
                source = futures[source]
                retry_counter = 0
                while True:
                    try:
                        future.result(timeout=multiprocessing.timeout)
                        break
                    except TimeoutError as e:
                        retry_counter += 1
                        if retry_counter > _MAX_RETRIES:
                            raise TimeoutError(e)
                    except Exception as e:
                        raise XSDataRootFinderError(
                            "Task was not completed succesfully", source
                        ) from e
    else:
        for source in sources:
            _visit_and_consolidate(source, gen_model, consolidated_classes)

    return consolidated_classes.root_finder()